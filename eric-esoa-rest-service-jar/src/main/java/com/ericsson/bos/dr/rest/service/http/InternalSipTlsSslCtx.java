/*******************************************************************************
 * COPYRIGHT Ericsson 2023
 *
 *
 *
 * The copyright to the computer program(s) herein is the property of
 *
 * Ericsson Inc. The programs may be used and/or copied only with written
 *
 * permission from Ericsson Inc. or in accordance with the terms and
 *
 * conditions stipulated in the agreement/contract under which the
 *
 * program(s) have been supplied.
 ******************************************************************************/

package com.ericsson.bos.dr.rest.service.http;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.util.Base64;

import com.ericsson.bos.dr.rest.service.exceptions.ErrorCode;
import com.ericsson.bos.dr.rest.service.exceptions.RestServiceException;
import com.ericsson.bos.so.security.mtls.MtlsConfigurationReloadersRegister;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * Provides SslContext for secure communication with internal services using certs generated by SIP-TLS service.
 * The eric-eso-mtls-helper library ensures that the certs/keys are stored in a JKS trust and key store, from where they
 * are loaded.
 */
@Component
public class InternalSipTlsSslCtx {

    private static final Logger LOGGER = LoggerFactory.getLogger(InternalSipTlsSslCtx.class);

    @Value("${security.truststore.path:}")
    private String trustStorePath;

    @Value("${security.cryptoStoreParams.storePass}")
    private String storePass;

    @Value("${security.keystore.path}")
    private String keyStorePath;

    private SslContext sslContext;

    /**
     * Register for updates to sip-tls keystores in order. The SslContext
     * will be created
     */
    @PostConstruct
    void registerForKeystoreChanges() {
        MtlsConfigurationReloadersRegister.getInstance().register(() -> {
            if (InternalSipTlsSslCtx.this.sslContext != null) {
                LOGGER.info("Recreating SslContext, sip-tls keystores have been updated");
                createSslContext();
            }
        });
    }

    /**
     * Returns an SSL Context for internal service communication.
     *
     * @return the SSL Context.
     */
    synchronized SslContext get() {
        if (sslContext == null) {
            createSslContext();
        }
        return sslContext;
    }

    private synchronized void createSslContext() {
        try {
            sslContext = SslContextBuilder.forClient()
                    .trustManager(getTrustManagerFactory())
                    .keyManager(getKeyManagerFactory())
                    .build();
        } catch(final Exception e) {
            throw new RestServiceException(e, ErrorCode.GENERAL_ERROR, e.getMessage());
        }
    }

    private TrustManagerFactory getTrustManagerFactory() throws KeyStoreException, IOException, CertificateException, NoSuchAlgorithmException {
        try (InputStream trustStoreStream = Files.newInputStream(Paths.get(trustStorePath), StandardOpenOption.READ)) {
            final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(trustStoreStream, getStorePass().toCharArray());
            final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);
            return trustManagerFactory;
        }
    }

    private KeyManagerFactory getKeyManagerFactory()
            throws KeyStoreException, IOException, CertificateException, NoSuchAlgorithmException, UnrecoverableKeyException {
        try (InputStream keyStoreStream = Files.newInputStream(Paths.get(keyStorePath), StandardOpenOption.READ)) {
            final KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(keyStoreStream, getStorePass().toCharArray()); // Note: eric-esoa-mtls-helper uses the store pass for both
            // the key store and trust store.
            final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
            keyManagerFactory.init(keyStore, getStorePass().toCharArray());
            return keyManagerFactory;
        }
    }

    private String getStorePass() {
        return decodePassword(storePass);
    }

    private String decodePassword(final String pass) {
        return new String(Base64.getDecoder().decode(pass), StandardCharsets.UTF_8);
    }
}